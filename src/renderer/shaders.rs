// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.21.3
// Changes made to this file will not be saved.
// SourceHash: 9d595b3fddf4d5cdf8f8da4335d60045b351f316b2f1a5afb1372cf60c3182c2

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Scene,
    Skybox,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::Scene => scene::create_pipeline_layout(device),
            Self::Skybox => skybox::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(&self, device: &wgpu::Device) -> wgpu::ShaderModule {
        match self {
            Self::Scene => scene::create_shader_module_embed_source(device),
            Self::Skybox => skybox::create_shader_module_embed_source(device),
        }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::RenderPass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::RenderBundleEncoder<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {
        assert!(std::mem::size_of::<glam::IVec2>() == 8);
        assert!(std::mem::align_of::<glam::IVec2>() == 4);
        assert!(std::mem::size_of::<glam::IVec3>() == 12);
        assert!(std::mem::align_of::<glam::IVec3>() == 4);
        assert!(std::mem::size_of::<glam::IVec4>() == 16);
        assert!(std::mem::align_of::<glam::IVec4>() == 4);
        assert!(std::mem::size_of::<glam::UVec2>() == 8);
        assert!(std::mem::align_of::<glam::UVec2>() == 4);
        assert!(std::mem::size_of::<glam::UVec3>() == 12);
        assert!(std::mem::align_of::<glam::UVec3>() == 4);
        assert!(std::mem::size_of::<glam::UVec4>() == 16);
        assert!(std::mem::align_of::<glam::UVec4>() == 4);
        assert!(std::mem::size_of::<glam::Vec2>() == 8);
        assert!(std::mem::align_of::<glam::Vec2>() == 4);
        assert!(std::mem::size_of::<glam::Vec3>() == 12);
        assert!(std::mem::align_of::<glam::Vec3>() == 4);
        assert!(std::mem::size_of::<glam::Vec4>() == 16);
        assert!(std::mem::align_of::<glam::Vec4>() == 16);
        assert!(std::mem::size_of::<glam::Mat2>() == 16);
        assert!(std::mem::align_of::<glam::Mat2>() == 16);
        assert!(std::mem::size_of::<glam::Mat3A>() == 48);
        assert!(std::mem::align_of::<glam::Mat3A>() == 16);
        assert!(std::mem::size_of::<glam::Mat4>() == 64);
        assert!(std::mem::align_of::<glam::Mat4>() == 16);
    };
    const BGROUP_CAMERA_CAMERA_ASSERTS: () = {
        assert!(std::mem::offset_of!(bgroup_camera::Camera, view) == 0);
        assert!(std::mem::offset_of!(bgroup_camera::Camera, view_inv) == 64);
        assert!(std::mem::offset_of!(bgroup_camera::Camera, proj) == 128);
        assert!(std::mem::offset_of!(bgroup_camera::Camera, proj_inv) == 192);
        assert!(std::mem::size_of::<bgroup_camera::Camera>() == 256);
    };
    const SCENE_NODE_ASSERTS: () = {
        assert!(std::mem::offset_of!(scene::Node, transform) == 0);
        assert!(std::mem::offset_of!(scene::Node, normal_transform) == 64);
        assert!(std::mem::size_of::<scene::Node>() == 128);
    };
}
pub mod bgroup_camera {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy, serde :: Serialize, serde :: Deserialize)]
    pub struct Camera {
        #[doc = "offset: 0, size: 64, type: `mat4x4<f32>`"]
        pub view: glam::Mat4,
        #[doc = "offset: 64, size: 64, type: `mat4x4<f32>`"]
        pub view_inv: glam::Mat4,
        #[doc = "offset: 128, size: 64, type: `mat4x4<f32>`"]
        pub proj: glam::Mat4,
        #[doc = "offset: 192, size: 64, type: `mat4x4<f32>`"]
        pub proj_inv: glam::Mat4,
    }
    impl Camera {
        pub const fn new(
            view: glam::Mat4,
            view_inv: glam::Mat4,
            proj: glam::Mat4,
            proj_inv: glam::Mat4,
        ) -> Self {
            Self {
                view,
                view_inv,
                proj,
                proj_inv,
            }
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub res_camera: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub res_camera: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                res_camera: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.res_camera),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.res_camera]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("BgroupCamera::BindGroup0::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"_root::bgroup_camera::res_camera\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::bgroup_camera::Camera,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup0Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("BgroupCamera::BindGroup0"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for bgroup_camera::Camera {}
    unsafe impl bytemuck::Pod for bgroup_camera::Camera {}
    unsafe impl bytemuck::Zeroable for scene::Node {}
    unsafe impl bytemuck::Pod for scene::Node {}
    unsafe impl bytemuck::Zeroable for scene::VertexInput {}
    unsafe impl bytemuck::Pod for scene::VertexInput {}
}
pub mod scene {
    use super::{_root, _root::*};
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy, serde :: Serialize, serde :: Deserialize)]
    pub struct Node {
        #[doc = "offset: 0, size: 64, type: `mat4x4<f32>`"]
        pub transform: glam::Mat4,
        #[doc = "offset: 64, size: 64, type: `mat4x4<f32>`"]
        pub normal_transform: glam::Mat4,
    }
    impl Node {
        pub const fn new(transform: glam::Mat4, normal_transform: glam::Mat4) -> Self {
            Self {
                transform,
                normal_transform,
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy, serde :: Serialize, serde :: Deserialize)]
    pub struct VertexInput {
        pub position: glam::Vec3,
        pub normal: glam::Vec3,
    }
    impl VertexInput {
        pub const fn new(position: glam::Vec3, normal: glam::Vec3) -> Self {
            Self { position, normal }
        }
    }
    impl VertexInput {
        pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 2] = [
            wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x3,
                offset: std::mem::offset_of!(Self, position) as u64,
                shader_location: 0,
            },
            wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x3,
                offset: std::mem::offset_of!(Self, normal) as u64,
                shader_location: 1,
            },
        ];
        pub const fn vertex_buffer_layout(
            step_mode: wgpu::VertexStepMode,
        ) -> wgpu::VertexBufferLayout<'static> {
            wgpu::VertexBufferLayout {
                array_stride: std::mem::size_of::<Self>() as u64,
                step_mode,
                attributes: &Self::VERTEX_ATTRIBUTES,
            }
        }
    }
    pub const ENTRY_VS_SCENE: &str = "vs_scene";
    pub const ENTRY_FS_SCENE: &str = "fs_scene";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn vs_scene_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
        VertexEntry {
            entry_point: ENTRY_VS_SCENE,
            buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn fragment_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn fs_scene_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
        FragmentEntry {
            entry_point: ENTRY_FS_SCENE,
            targets,
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub res_node: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub res_node: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                res_node: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.res_node),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.res_node]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Scene::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"res_node\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                        ty: wgpu::BindingType::Buffer {
                            ty: wgpu::BufferBindingType::Uniform,
                            has_dynamic_offset: false,
                            min_binding_size: std::num::NonZeroU64::new(std::mem::size_of::<
                                _root::scene::Node,
                            >(
                            )
                                as _),
                        },
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Scene::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a bgroup_camera::WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Scene::PipelineLayout"),
            bind_group_layouts: &[
                &bgroup_camera::WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("scene.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct CameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX {
    view: mat4x4<f32>,
    view_inv: mat4x4<f32>,
    proj: mat4x4<f32>,
    proj_inv: mat4x4<f32>,
}

struct Node {
    transform: mat4x4<f32>,
    normal_transform: mat4x4<f32>,
}

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
}

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) normal: vec3<f32>,
}

const LIGHT_DIR: vec3<f32> = vec3<f32>(0.25f, 0.5f, 1f);
const AMBIENT_COLOR: vec3<f32> = vec3(0.1f);

@group(0) @binding(0) 
var<uniform> res_cameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX: CameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX;
@group(1) @binding(0) 
var<uniform> res_node: Node;

@vertex 
fn vs_scene(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;

    let _e4 = res_cameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX.proj;
    let _e7 = res_cameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX.view;
    let _e12 = res_node.transform;
    output.position = (((_e4 * _e7) * _e12) * vec4<f32>(input.position, 1f));
    let _e21 = res_cameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX.view;
    let _e24 = res_node.normal_transform;
    output.normal = ((_e21 * _e24) * vec4<f32>(input.normal, 0f)).xyz;
    let _e31 = output;
    return _e31;
}

@fragment 
fn fs_scene(input_1: VertexOutput) -> @location(0) vec4<f32> {
    let N = normalize(input_1.normal);
    let L = normalize(LIGHT_DIR);
    let NDotL = max(dot(N, L), 0f);
    let surface_color = (AMBIENT_COLOR + vec3(NDotL));
    return vec4<f32>(((vec3(1f) + N) / vec3(2f)), 1f);
}
"#;
}
pub mod skybox {
    use super::{_root, _root::*};
    pub const ENTRY_VS_SKYBOX: &str = "vs_skybox";
    pub const ENTRY_FS_SKYBOX: &str = "fs_skybox";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn vs_skybox_entry() -> VertexEntry<0> {
        VertexEntry {
            entry_point: ENTRY_VS_SKYBOX,
            buffers: [],
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: Vec<(&'static str, f64)>,
    }
    pub fn fragment_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn fs_skybox_entry(targets: [Option<wgpu::ColorTargetState>; 1]) -> FragmentEntry<1> {
        FragmentEntry {
            entry_point: ENTRY_FS_SKYBOX,
            targets,
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub res_texture: &'a wgpu::TextureView,
        pub res_sampler: &'a wgpu::Sampler,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub res_texture: wgpu::BindGroupEntry<'a>,
        pub res_sampler: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                res_texture: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(params.res_texture),
                },
                res_sampler: wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(params.res_sampler),
                },
            }
        }
        pub fn into_array(self) -> [wgpu::BindGroupEntry<'a>; 2] {
            [self.res_texture, self.res_sampler]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.into_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> =
            wgpu::BindGroupLayoutDescriptor {
                label: Some("Skybox::BindGroup1::LayoutDescriptor"),
                entries: &[
                    #[doc = " @binding(0): \"res_texture\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                        ty: wgpu::BindingType::Texture {
                            sample_type: wgpu::TextureSampleType::Float { filterable: true },
                            view_dimension: wgpu::TextureViewDimension::Cube,
                            multisampled: false,
                        },
                        count: None,
                    },
                    #[doc = " @binding(1): \"res_sampler\""]
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                        ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                        count: None,
                    },
                ],
            };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: WgpuBindGroup1Entries) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(device);
            let entries = bindings.into_array();
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("Skybox::BindGroup1"),
                layout: &bind_group_layout,
                entries: &entries,
            });
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[doc = " Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`."]
    #[doc = " For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:"]
    #[doc = "   - Bind group 0: Least frequent updates (e.g. per frame resources)"]
    #[doc = "   - Bind group 1: More frequent updates"]
    #[doc = "   - Bind group 2: More frequent updates"]
    #[doc = "   - Bind group 3: Most frequent updates (e.g. per draw resources)"]
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a bgroup_camera::WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 2],
        ) -> [wgpu::BindGroupLayout; 2] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("Skybox::PipelineLayout"),
            bind_group_layouts: &[
                &bgroup_camera::WgpuBindGroup0::get_bind_group_layout(device),
                &WgpuBindGroup1::get_bind_group_layout(device),
            ],
            push_constant_ranges: &[],
        })
    }
    pub fn create_shader_module_embed_source(device: &wgpu::Device) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("skybox.wgsl"),
            source: wgpu::ShaderSource::Wgsl(source),
        })
    }
    pub const SHADER_STRING: &str = r#"
struct CameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX {
    view: mat4x4<f32>,
    view_inv: mat4x4<f32>,
    proj: mat4x4<f32>,
    proj_inv: mat4x4<f32>,
}

struct SkyboxInterp {
    @builtin(position) position: vec4<f32>,
    @location(0) tex_coord: vec3<f32>,
}

@group(0) @binding(0) 
var<uniform> res_cameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX: CameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX;
@group(1) @binding(0) 
var res_texture: texture_cube<f32>;
@group(1) @binding(1) 
var res_sampler: sampler;

@vertex 
fn vs_skybox(@builtin(vertex_index) vertex_index: u32) -> SkyboxInterp {
    var result: SkyboxInterp;

    let tmp1_ = (i32(vertex_index) / 2i);
    let tmp2_ = (i32(vertex_index) & 1i);
    let pos = vec4<f32>(((f32(tmp1_) * 4f) - 1f), ((f32(tmp2_) * 4f) - 1f), 1f, 1f);
    result.position = pos;
    let _e24 = res_cameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX.proj_inv;
    let dir = vec4<f32>((_e24 * pos).xyz, 0f);
    let _e32 = res_cameraX_naga_oil_mod_XMJTXE33VOBPWGYLNMVZGCX.view_inv;
    result.tex_coord = (_e32 * dir).xyz;
    let _e35 = result;
    return _e35;
}

@fragment 
fn fs_skybox(vertex: SkyboxInterp) -> @location(0) vec4<f32> {
    let _e4 = textureSample(res_texture, res_sampler, vertex.tex_coord);
    return _e4;
}
"#;
}
